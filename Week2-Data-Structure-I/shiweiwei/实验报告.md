#实验一 布隆过滤器
##布隆过滤器的实现
* `hash.h`和`hash.cpp`：包含使用到的8个哈希函数BKDR，AP，RS，JS，SDBM，DJB，DEK，Murmur。  
参考[常见Hash算法](https://cloud.tencent.com/developer/article/1432686)以及[常用的Hash算法](https://www.cnblogs.com/rainy-shurun/p/5426570.html)，排除掉第一个博客中提到的效果最差的两个哈希函数PJW和ELF，从剩下的哈希函数中随意选出8个。
* `BloomFilter.h`和`BloomFilter.cpp`：布隆过滤器的实现函数，包括函数：
    * `gethash`：对于每个输入得到8个哈希函数的结果。
    * `add`：过滤器插入功能。主要使用bitset的set函数将得到的8个哈希函数的结果对应的bit位设置为1。
    * `isContain`：过滤器查询功能。主要使用bitset的test函数查看得到的8个哈希函数的结果对应的bit位是否为1。
##布隆过滤器的测试
* `main.cpp`：布隆过滤器的测试函数。在这里，bit的大小设置为8629，首先完成0-1000数字的插入，再对1000-1999这1000个并未插入的数字进行查询，查看误报为查询成功的数字个数。  
同时测试者可自行进行测试，进行插入及查询操作。
##布隆过滤器的结果
![测试结果](BloomTest.png)
##遇到的问题
由于C++中bitset的初始化只能为确定的大小，所以没有使用公式计算bitset的大小以及Hash函数的个数。
##TO DO
后续可以尝试一下计数布隆过滤器的实现。


#实验二 布谷鸟过滤器
##布谷鸟过滤器的实现
* `CuckooFilter.h`和`CuckooFilter.cpp`：布谷鸟过滤器的实现函数，包括函数：
    * `FingerPrint`：得到指纹的哈希函数，使用的是BKDR哈希函数。
    * `MurmurHash`：得到数据对应位置的哈希函数，使用的是Murmur哈希函数。
    * `add`：过滤器插入功能。如果过滤器对应位置有空，则直接插入；如果没有，则踢出过滤器对应位置的随机一个数，插入指纹，同时为踢出的数重新找位置。以此类推。同时踢出的次数要有个阈值，如果一次插入操作达到这个阈值，说明该过滤器需要进行扩容了。
    * `isContain`：过滤器查询功能。查找过滤器对应位置是否有该数据。
    * `Delete`：过滤器删除功能。在过滤器对应位置找到该数并将插入的指纹清除，恢复为初始值。
##布谷鸟过滤器的测试
* `main.cpp`：布隆过滤器的测试函数。在这里，过滤器使用的二维数组存放数据，第一维的大小为8629，第二维的大小为1，允许的最大踢出次数为10。当踢的次数达到阈值，则会输出需要扩容的提示。测试了一下，相同容量下，布谷鸟过滤器大概在插入4000左右数据的时候会提示需要进行扩容，但是布谷鸟过滤器此时仍然没有误报。
同时测试者可自行进行测试，进行插入、查询及删除操作。
##布谷鸟过滤器的结果
![测试结果](CuckooTest.png)
##遇到的问题
在插入时，数组可能产生溢出。
解决：在求第二个哈希值时使用异或的公式需要再进行一个求余操作，因为异或操作得到的值可能超出数组范围。
##TO DO
如果要进行扩容，需要重置数组的大小，这时需要将数组换为容器vector。


#对比
布谷鸟过滤器要比布隆过滤器要好。  
1.布谷鸟过滤器在没有溢出的情况下出现假阳性的概率要小，布谷鸟是因为可能出现相同的指纹，布隆是因为bit位相同；  
2.布谷鸟过滤器每个元素需要的存储空间更少，也就是说布谷鸟过滤器的空间性能要好，因为它只用了两个哈希函数来求存储位置；  
3.布谷鸟过滤器的查询性能也要好，因为哈希函数的个数要少；  
4.布谷鸟过滤器可以进行删除操作，但是对于基础的布隆过滤器来说并不支持删除操作。
